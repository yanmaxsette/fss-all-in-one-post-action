AWSTemplateFormatVersion: 2010-09-09

Description: Trend Micro File Storage Security scanner and storage stacks + post scan actions + automated in FSS Console

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "[ Mandatory ]"
        Parameters:
          - C1API
          - ExternalID
          - S3BucketToScan
          - PromoteBucketName
          - PromoteMode
          - QuarantineBucketName
          - QuarantineMode
      - Label:
          default: "[ Customizable section ]"
        Parameters:
          - ObjectFilterPrefix
          - KMSKeyARNForBucketSSE
          - KMSKeyARNForQueueSSE
          - KMSKeyARNForTopicSSE
          - ScannerEphemeralStorage
          - TriggerWithObjectCreatedEvent
          - ReportObjectKey
          - ScanOnGetObject
      - Label:
          default: "[ Optional: Permissions control ]"
        Parameters:
          - PermissionsBoundary
          - AdditionalIAMPolicies
          - ACL
      - Label:
          default: "[ Optional: Resource prefixes ] Warning: Do not modify these fields when you update the stack. This may cause management problems. The maximum prefix length is 50 characters."
        Parameters:
          - IAMRolePrefix
          - IAMPolicyPrefix
          - LambdaFunctionPrefix
          - LambdaLayerPrefix
          - SQSQueuePrefix
          - SNSTopicPrefix
      - Label:
          default: "[ Optional: Deploy in VPC ] Warning: Make sure the subnets have access to domains .amazonaws.com and .trendmicro.com over HTTPS"
        Parameters:
          - SubnetIDs
          - SecurityGroupIDs
          - NetworkProxy
      - Label:
          default: "[ Optional: Storage stack dead-letter queues ARNs ] The SQS ARNs for dead-letter queues can all be the same value. They have to be both deployed in the same region and managed by the same account as the storage stack."
        Parameters:
          - BucketListenerDLQARN
          - PostScanActionTagDLQARN
          - ScanResultTopicDLQARN
          - KMSKeyARNForDLQSSE
      - Label:
          default: "[ Warning: Do not modify the fields below. Modifications may cause your deployment to fail. ]"
        Parameters:
          - FSSBucketName
          - FSSKeyPrefix
          - TrendMicroManagementAccount
          - CloudOneRegion

    ParameterLabels:
      AdditionalIAMPolicies:
        default: AdditionalIAMPolicies
      BucketListenerDLQARN:
        default: SQS ARN for BucketListenerLambda DLQ
      CloudOneRegion:
        default: Trend Micro Cloud One region
      ExternalID:
        default: ExternalID
      FSSBucketName:
        default: Stack package location
      FSSKeyPrefix:
        default: Version
      IAMPolicyPrefix:
        default: Prefix for IAM policy name
      IAMRolePrefix:
        default: Prefix for IAM role name
      KMSKeyARNForBucketSSE:
        default: KMSKeyARNForBucketSSE
      KMSKeyARNForDLQSSE:
        default: KMSKeyARNForDLQSSE
      KMSKeyARNForQueueSSE:
        default: KMSKeyARNForQueueSSE
      KMSKeyARNForTopicSSE:
        default: KMSKeyARNForTopicSSE
      LambdaFunctionPrefix:
        default: "Prefix for Lambda function name [ Warning: Do not modify this field when you update the stack. Modifications may cause your update to fail. ]"
      LambdaLayerPrefix:
        default: Prefix for Lambda layer name
      NetworkProxy:
        default: NetworkProxy
      ObjectFilterPrefix:
        default: ObjectFilterPrefix
      PermissionsBoundary:
        default: PermissionsBoundary
      PostScanActionTagDLQARN:
        default: SQS ARN for PostScanActionTagLambda DLQ
      ReportObjectKey:
        default: ReportObjectKey
      S3BucketToScan:
        default: S3BucketToScan
      ScannerEphemeralStorage:
        default: "ScannerEphemeralStorage [ In Preview ]"
      ScanOnGetObject:
        default: "ScanOnGetObject [ In Preview ]"
      ScanResultTopicDLQARN:
        default: ScanResultTopicDLQARN
      SecurityGroupIDs:
        default: SecurityGroupIDs
      SNSTopicPrefix:
        default: Prefix for SNS topic name
      SQSQueuePrefix:
        default: Prefix for SQS queue name
      SubnetIDs:
        default: SubnetIDs
      TrendMicroManagementAccount:
        default: File Storage Security management account
      TriggerWithObjectCreatedEvent:
        default: TriggerWithObjectCreatedEvent

Parameters:
  C1API:
    Type: String
    NoEcho: true
    Description: Enter your Cloud One API Key
  AdditionalIAMPolicies:
    Default: ""
    Description: A comma-separated list of IAM policy ARNs to attach to all the roles that will be created.
    Type: CommaDelimitedList
  BucketListenerDLQARN:
    Default: ""
    Description: The SQS ARN for BucketListenerLambda DLQ.
    Type: String
  CloudOneRegion:
    Description: The region of the Trend Micro Cloud One services.
    Type: String
    Default: us-1
  ExternalID:
    Description: "The External ID is for future use with updating Lambdas and also to address and prevent the 'confused deputy' problem."
    Type: String
  FSSBucketName:
    ConstraintDescription:
      File Storage Security bucket name can include numbers, lowercase
      letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen
      (-).
    Default: file-storage-security
    Description: ""
    Type: String
  FSSKeyPrefix:
    ConstraintDescription:
      File Storage Security key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), and forward slash (/).
    Default: latest/
    Description: ""
    Type: String
  IAMPolicyPrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9+=,.@\-_]+-$
    ConstraintDescription: Prefix for IAM policy name can be empty or include alphanumeric and '+=,.@-_' characters and must end with a hyphen. The maximum length is 50 characters.
    Default: ""
    Description: Prefix for the name of the IAM Policies. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  IAMRolePrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9+=,.@\-_]+-$
    ConstraintDescription: Prefix for IAM role name can be empty or include alphanumeric and '+=,.@-_' characters and must end with a hyphen. The maximum length is 50 characters.
    Default: ""
    Description: Prefix for the name of the IAM roles being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  KMSKeyARNForBucketSSE:
    Default: ""
    Description: The ARN for the KMS master key used to encrypt S3 bucket objects. Leave it blank if you haven't enabled SSE-KMS for the bucket.
    Type: String
  KMSKeyARNForDLQSSE:
    Default: ""
    Description: The ARN for the KMS master key used to encrypt messages of DLQ for storage stack. Leave it blank if you haven't used your own CMK for SQS server-side encryption on the queue ARNs you provided.
    Type: String
  KMSKeyARNForQueueSSE:
    Default: ""
    Description: The ARN for the KMS master key used to encrypt messages in SQS. Leave it blank if you haven't used your own CMK for SQS server-side encryption.
    Type: String
  KMSKeyARNForTopicSSE:
    Default: ""
    Description: The ARN for the KMS master key used to encrypt messages in SNS. Leave it blank if you haven't used your own CMK for SNS server-side encryption.
    Type: String
  LambdaFunctionPrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9_\-]+-$
    ConstraintDescription: Prefix for Lambda function name can be empty or include letters, numbers, hyphens (-), and underscores (_) and must end with a hyphen. The maximum length is 50 characters.
    Default: ""
    Description: Prefix for the name of the Lambda functions being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  LambdaLayerPrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9_\-]+-$
    ConstraintDescription: Prefix for Lambda layer name can be empty or include letters, numbers, hyphens (-), and underscores (_) and must end with a hyphen. The maximum length is 50 characters.
    Default: ""
    Description: Prefix for the name of the Lambda layers being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  NetworkProxy:
    Default: ""
    Description: Network proxy setting in the format scheme://[user:pass@]host:port, for example http://proxy.server:8080. Leave it blank if you don't want Lambda functions to connect to an explicit proxy in the VPC.
    Type: String
  ObjectFilterPrefix:
    Default: ""
    Description: Limit the scan to objects whose key starts with the specified characters.
    Type: String
  PermissionsBoundary:
    Default: ""
    Description: The ARN of the policy used to set the permissions boundary for all the roles that will be created.
    Type: String
  PostScanActionTagDLQARN:
    Default: ""
    Description: The SQS ARN for PostScanActionTag DLQ.
    Type: String
  ReportObjectKey:
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description: |-
      Enable this to report the object keys of the scanned objects to File Storage Security backend services.
      File Storage Security can then display the object keys of the malicious objects in the response of events API.
    Type: String
  S3BucketToScan:
    Description: The S3 bucket to scan. Specify an existing S3 bucket.
    Type: String
  ScannerEphemeralStorage:
    Default: 512
    Description: |
      The size of the scanner lambda function's temp directory in MB. The default value is 512, but it can be any whole number between 512 and 2048 MB.
      Configure a large ephemeral storage to scan larger files in zip files.
      For more information, see https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-ephemeral-storage
    Type: Number
    MinValue: 512
    MaxValue: 2048
  ScanOnGetObject:
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description: |
      Scan objects retrieved (GET requests) from S3 with the Object Lambda Access Point.
      This option requires that the storage stack is deployed in both the same account and the same region as the scanner stack.
      For more information, see https://cloudone.trendmicro.com/docs/file-storage-security/aws-scan-on-get-object/
    Type: String
  ScanResultTopicDLQARN:
    Default: ""
    Description: The SQS ARN for ScanResultTopic DLQ.
    Type: String
  SecurityGroupIDs:
    Default: ""
    Description: A comma-separated list of VPC Security Group IDs that are attached to Lambda functions. Leave it blank if you don't want to attach Lambda functions to a VPC.
    Type: CommaDelimitedList
  SNSTopicPrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9_\-]+-$
    ConstraintDescription: Prefix for SNS topic name can be empty or include include alphanumeric characters, hyphens (-) and underscores (_) and must end with a hyphen. The maximum length is 50 characters.
    Default: ""
    Description: Prefix for the name of SNS topics being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  SQSQueuePrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9_\-]+-$
    ConstraintDescription: Prefix for SQS queue name can be empty or include alphanumeric characters, hyphens (-), and underscores (_) and must end with a hyphen. The maximum length is 50 characters.
    Default: ""
    Description: Prefix for the name of SQS queues being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  SubnetIDs:
    Default: ""
    Description: A comma-separated list of VPC Subnet IDs that are attached to Lambda functions. Leave it blank if you don't want to attach Lambda functions to a VPC.
    Type: CommaDelimitedList
  TrendMicroManagementAccount:
    ConstraintDescription: AWS account ID.
    Default: 415485722356
    Description: This account will be given permission to modify the stacks for upgrades and troubleshooting purposes.
    Type: String
  TriggerWithObjectCreatedEvent:
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description: If the s3:ObjectCreated:* event of the S3BucketToScan is in use, set this option to false. Then trigger the scans by invoking the deployed BucketListenerLambda.
    Type: String
  PromoteBucketName:
    Type: String
    Default: ''
    Description: |
      [Optional] The bucket name used to promote files without malicious intent.
      Leave the bucket name blank to disable promoting.
  PromoteMode:
    Type: String
    AllowedValues:
      - move
      - copy
    Default: move
    Description: |
      The method by which files were promoted.
      (Options: move, copy)
  QuarantineBucketName:
    Type: String
    Default: ''
    Description: |
      [Optional] The bucket name to quarantine malicious files.
      Leave the bucket name blank to disable quarantining
  QuarantineMode:
    Type: String
    AllowedValues:
      - move
      - copy
    Default: move
    Description: |
      The method by which files were quarantined.
      (Options: move, copy)
  ACL:
    Type: String
    AllowedValues:
      - ''
      - 'private'
      - 'public-read'
      - 'public-read-write'
      - 'authenticated-read'
      - 'aws-exec-read'
      - 'bucket-owner-read'
      - 'bucket-owner-full-control'
    Default: ''
    Description: |
      [Optional] Apply an access control list (ACL) on the file after it has been promoted or quarantined.
      (Options: private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, bucket-owner-full-control)

Conditions:
  HasAdditionalIAMPolicies:
    !Not [!Equals ["", !Select [0, !Ref AdditionalIAMPolicies]]]
  HasIAMPolicyPrefix: !Not [!Equals ["", !Ref IAMPolicyPrefix]]
  HasIAMRolePrefix: !Not [!Equals ["", !Ref IAMRolePrefix]]
  HasLambdaFunctionPrefix: !Not [!Equals ["", !Ref LambdaFunctionPrefix]]
  HasPermissionsBoundary: !Not [!Equals ["", !Ref PermissionsBoundary]]
  HasSNSTopicPrefix: !Not [!Equals ["", !Ref SNSTopicPrefix]]
  IsBucketListenerDLQEnabled: !Not [!Equals ["", !Ref BucketListenerDLQARN]]
  IsBucketListenerDLQSSEKMSEnabled: !And
    - !Condition IsBucketListenerDLQEnabled
    - !Condition IsDLQSSEKMSEnabled
  IsBucketSSEKMSEnabled: !Not [!Equals ["", !Ref KMSKeyARNForBucketSSE]]
  IsDLQSSEKMSEnabled: !Not [!Equals ["", !Ref KMSKeyARNForDLQSSE]]
  IsPostScanActionTagDLQEnabled:
    !Not [!Equals ["", !Ref PostScanActionTagDLQARN]]
  IsPostScanActionTagDLQSSEKMSEnabled: !And
    - !Condition IsPostScanActionTagDLQEnabled
    - !Condition IsDLQSSEKMSEnabled
  IsQueueSSEKMSEnabled: !Not [!Equals ["", !Ref KMSKeyARNForQueueSSE]]
  IsReportObjectKey: !Equals ["true", !Ref ReportObjectKey]
  IsTopicSSEKMSEnabled: !Not [!Equals ["", !Ref KMSKeyARNForTopicSSE]]
  IsTriggeredWithObjectCreatedEvent:
    !Equals ["true", !Ref TriggerWithObjectCreatedEvent]
  IsScanOnGetObjectEnabled: !Equals ["true", !Ref ScanOnGetObject]
  IsScanResultTopicDLQEnabled: !Not [!Equals ["", !Ref ScanResultTopicDLQARN]]
  IsVPCEnabled: !And
    - !Not [!Equals ["", !Select [0, !Ref SubnetIDs]]]
    - !Not [!Equals ["", !Select [0, !Ref SecurityGroupIDs]]]
  IsProxyEnabled: !And
    - !Condition IsVPCEnabled
    - !Not [!Equals ["", !Ref NetworkProxy]]
  HasLambdaLayerPrefix: !Not [!Equals ["", !Ref LambdaLayerPrefix]]
  HasSQSQueuePrefix: !Not [!Equals ["", !Ref SQSQueuePrefix]]
  PromoteEnabled:
    !Not [!Equals [!Ref PromoteBucketName, '']]
  QuarantineEnabled:
    !Not [!Equals [!Ref QuarantineBucketName, '']]
  PutACL:
    !Not [!Equals [!Ref ACL, '']]

Resources:
  c1api:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: C1 API KEY
      SecretString: !Sub '{"c1apikey":"${C1API}"}'
  CreateLambdaAliasLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join [
            "",
            [
              !Ref LambdaFunctionPrefix,
              "alias-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Description: Create Lambda alias on Lambda function
      Handler: index.handler
      Runtime: python3.8
      Role: !GetAtt CreateLambdaAliasExecutionRole.Arn
      Timeout: 120
      Environment:
        Variables:
          HTTPS_PROXY:
            !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds:
          !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      Code:
        ZipFile: |
          import boto3
          import traceback
          import json
          import urllib.request
          import time
          SUCCESS = "SUCCESS"
          FAILED = "FAILED"
          lambda_client = boto3.client('lambda')
          def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False):
              responseUrl = event['ResponseURL']
              print(responseUrl)
              responseBody = {}
              responseBody['Status'] = responseStatus
              responseBody['Reason'] = 'See the details in CloudWatch Log Stream: ' + context.log_stream_name
              responseBody['PhysicalResourceId'] = physicalResourceId or context.log_stream_name
              responseBody['StackId'] = event['StackId']
              responseBody['RequestId'] = event['RequestId']
              responseBody['LogicalResourceId'] = event['LogicalResourceId']
              responseBody['NoEcho'] = noEcho
              responseBody['Data'] = responseData
              json_responseBody = json.dumps(responseBody)
              print("Response body:\n" + json_responseBody)
              headers = {
                  'content-type' : '',
                  'content-length' : str(len(json_responseBody))
              }
              request = urllib.request.Request(responseUrl, headers=headers, data=json_responseBody.encode('utf-8'), method='PUT')
              try:
                  with urllib.request.urlopen(request) as response:
                      print("Status code: " + response.reason)
              except Exception as e:
                  print("send(..) failed executing requests.put(..): " + str(e))
          def publish_version_with_retry(function, retry_attempts=6):
              try:
                  return lambda_client.publish_version(FunctionName=function)
              except lambda_client.exceptions.ResourceConflictException as e:
                  if retry_attempts > 0:
                      print('publish_version failed with ResourceConflictException, retrying in 10 seconds...')
                      time.sleep(10)
                      return publish_version_with_retry(function, retry_attempts-1)
                  else: raise e
          def create_alias(function, name):
              version_result = publish_version_with_retry(function)
              return lambda_client.create_alias(FunctionName=function, Name=name, FunctionVersion=version_result['Version'])
          def update_alias(function, name):
              version_result = publish_version_with_retry(function)
              return lambda_client.update_alias(FunctionName=function, Name=name, FunctionVersion=version_result['Version'], RoutingConfig={})
          def delete_alias(function, name):
              lambda_client.delete_alias(FunctionName=function, Name=name)
          def get_function_configuration(function, qualifier=None):
              if (qualifier is not None):
                  return lambda_client.get_function_configuration(FunctionName=function, Qualifier=qualifier)
              else:
                  return lambda_client.get_function_configuration(FunctionName=function)
          def update_function_configuration(function, environments, layers):
              lambda_client.update_function_configuration(FunctionName=function, Environment=environments, Layers=layers)
          def replace_environments(env_vars_to_recover, last_env_vars, current_environments):
              for env_var in env_vars_to_recover:
                  current_environments['Variables'][env_var] = last_env_vars.get(env_var, '')
              return current_environments
          def find_recover_layer_arn(layers, keyword):
              found_arns = [layer_arn for layer_arn in layers if keyword in layer_arn]
              return found_arns[0] if len(found_arns) > 0 else ''
          def is_not_match_layer(layer_arn, keywords):
              return len(list(filter(lambda keyword: keyword in layer_arn, keywords))) == 0
          def replace_layers(layers_to_recover, last_layers, current_layers):
              get_arn = lambda layer: layer['Arn']
              old_layer_arns = list(map(get_arn, last_layers))
              current_layer_arns = list(map(get_arn, current_layers))
              for recover_layer, replacing_layers in layers_to_recover.items():
                  recover_layer_arn = find_recover_layer_arn(old_layer_arns, recover_layer)
                  if len(recover_layer_arn) == 0: break
                  current_layer_arns = [layer_arn for layer_arn in current_layer_arns if is_not_match_layer(layer_arn, replacing_layers)]
                  current_layer_arns.append(recover_layer_arn)
              return current_layer_arns
          def recover_lambda_function_config(current_function_name, last_env_vars, last_layers, env_vars_to_recover, layers_to_recover):
              current_version_info = get_function_configuration(current_function_name)
              new_environments = replace_environments(env_vars_to_recover, last_env_vars, current_version_info['Environment'])
              new_layers = replace_layers(layers_to_recover, last_layers, current_version_info.get('Layers', []))
              update_function_configuration(current_function_name, new_environments, new_layers)
          def handler(event, context):
              # Do not print LastEnvVars values cause it might contain license (JWT)
              last_env_vars = event['ResourceProperties'].pop('LastEnvVars', {})
              event.get('OldResourceProperties', {}).pop('LastEnvVars', None)
              print(event)
              print('ResourceProperties.LastEnvVars:', last_env_vars.keys())
              status = SUCCESS
              response_data = {}
              try:
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      function_name = event['ResourceProperties']['FunctionName']
                      alias_name = event['ResourceProperties']['Name']
                      last_layers = event['ResourceProperties'].get('LastLayers', [])
                      env_vars_to_recover = event['ResourceProperties'].get('EnvVarsToRecover', [])
                      layers_to_recover = event['ResourceProperties'].get('LayersToRecover', {})
                      recover_lambda_function_config(function_name, last_env_vars, last_layers, env_vars_to_recover, layers_to_recover)
                      if event['RequestType'] == 'Create':
                          alias_result = create_alias(function_name, alias_name)
                      else:
                          old_function_name = event['OldResourceProperties']['FunctionName']
                          old_alias_name = event['OldResourceProperties']['Name']
                          if function_name == old_function_name and alias_name == old_alias_name:
                              alias_result = update_alias(function_name, alias_name)
                          else:
                              alias_result = create_alias(function_name, alias_name)
                              delete_alias(old_function_name, old_alias_name)
                      response_data = {'Arn': alias_result['AliasArn']}
              except Exception as ex:
                  print('Unhandled exception: ' + str(ex))
                  traceback.print_exc()
                  status = FAILED
              finally:
                  send(event, context, status, response_data, response_data.get('Arn', None))
  ScanResultTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !If
        - HasSNSTopicPrefix
        - !Join [
            "",
            [
              !Ref SNSTopicPrefix,
              "ScanResultTopic-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      DisplayName: S3 Scanning Results
      KmsMasterKeyId:
        !If [IsTopicSSEKMSEnabled, !Ref KMSKeyARNForTopicSSE, !Ref AWS::NoValue]
  ScanResultTopicSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: lambda
      Endpoint: !GetAtt PostScanActionTagLambdaAlias.Arn
      TopicArn: !Ref ScanResultTopic
      RedrivePolicy: !If
        - IsScanResultTopicDLQEnabled
        - deadLetterTargetArn: !Ref ScanResultTopicDLQARN
        - !Ref AWS::NoValue
  ScanResultTopicPolicy: #ROLE_TO_MOVE_TO_VALIDATE
    Type: AWS::SNS::TopicPolicy
    Properties:
      Topics:
        - !Ref ScanResultTopic
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sns:Publish
            Resource: !Ref ScanResultTopic
            Principal:
              AWS: !Ref AWS::AccountId
  BucketListenerLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join [
            "",
            [
              !Ref LambdaFunctionPrefix,
              "BL-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Code:
        S3Bucket: !Sub ${FSSBucketName}-${AWS::Region}
        S3Key: !Sub ${FSSKeyPrefix}lambda/bucket-listener.zip
      Handler: handler.lambda_handler
      Environment:
        Variables:
          SQSUrl: !Ref ScannerQueue
          SNSArn: !Ref ScanResultTopic
          stackARN: !Ref AWS::StackId
          REPORT_OBJECT_KEY: !If [IsReportObjectKey, "True", "False"]
          HTTPS_PROXY:
            !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      MemorySize: 128
      Role: !GetAtt BucketListenerExecutionRole.Arn
      Runtime: python3.8
      Timeout: 15
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds:
          !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      DeadLetterConfig:
        TargetArn:
          !If [
            IsBucketListenerDLQEnabled,
            !Ref BucketListenerDLQARN,
            !Ref AWS::NoValue,
          ]
  BucketListenerLambdaAlias:
    Type: Custom::BucketListenerLambdaAlias
    Properties:
      ServiceToken: !GetAtt CreateLambdaAliasLambda.Arn
      FunctionName: !GetAtt BucketListenerLambda.Arn
      Name: TM-FSS-MANAGED
      Modified: 20211111.1
      # Template parameters
      FSSBucketName: !Ref FSSBucketName
      FSSKeyPrefix: !Ref FSSKeyPrefix
      NetworkProxy: !Ref NetworkProxy
      ReportObjectKey: !Ref ReportObjectKey
      ScannerSQSURL: !Ref ScannerQueue
      SecurityGroupIDs: !Ref SecurityGroupIDs
      SubnetIDs: !Ref SubnetIDs
      # Other inputs
      ScanResultTopic: !Ref ScanResultTopic
  BucketListenerExecutionRole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "BL-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      ManagedPolicyArns: !Split
        - ","
        - !Join
          - ","
          - - !If
              - HasAdditionalIAMPolicies
              - !Join [",", !Ref AdditionalIAMPolicies]
              - !Ref AWS::NoValue
            - !If
              - IsVPCEnabled
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObjectTagging
                Resource: !Sub arn:${AWS::Partition}:s3:::${S3BucketToScan}/*
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource: !Join
                  - ":"
                  - - !Sub arn:${AWS::Partition}:sqs
                    # convert SQS URL (https://sqs.<REGION>.amazonaws.com/<ACCOUNT_ID>/<QUEUE_NAME>) to ARN
                    - !Select # region
                      - 1
                      - !Split
                        - .
                        - !Select [2, !Split [/, !Ref ScannerQueue]] # hostname sqs.<REGION>.amazonaws.com
                    - !Select [3, !Split [/, !Ref ScannerQueue]] # account ID
                    - !Select [4, !Split [/, !Ref ScannerQueue]] # queue name
  BucketListenerExecutionRoleKMSDecryptPolicy: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsBucketSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ["", [!Ref IAMPolicyPrefix, "kms-permission"]]
        - "kms-permission"
      Roles:
        - !Ref BucketListenerExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:Decrypt
            Resource: !Ref KMSKeyARNForBucketSSE
  BucketListenerExecutionRoleKMSDecryptPolicyForSQS: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsQueueSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ["", [!Ref IAMPolicyPrefix, "kms-permission-for-sqs"]]
        - "kms-permission-for-sqs"
      Roles:
        - !Ref BucketListenerExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:GenerateDataKey
              - kms:Decrypt
            Resource: !Ref KMSKeyARNForQueueSSE
  BucketListenerExecutionRolePolicyForDLQ: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsBucketListenerDLQEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ["", [!Ref IAMPolicyPrefix, "sqs-permission-for-dlq"]]
        - "sqs-permission-for-dlq"
      Roles:
        - !Ref BucketListenerExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sqs:SendMessage
            Resource: !Ref BucketListenerDLQARN
  BucketListenerExecutionRoleKMSDecryptPolicyForDLQ: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsBucketListenerDLQSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ["", [!Ref IAMPolicyPrefix, "kms-permission-for-dlq"]]
        - "kms-permission-for-dlq"
      Roles:
        - !Ref BucketListenerExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:Decrypt
              - kms:GenerateDataKey
            Resource: !Ref KMSKeyARNForDLQSSE
  BucketListenerInvokePermissionOfScanningBucket: #ROLE_TO_MOVE_TO_VALIDATE
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt BucketListenerLambdaAlias.Arn
      Principal: s3.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !Sub arn:${AWS::Partition}:s3:::${S3BucketToScan}
  BucketListenerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [/, [/aws/lambda, !Ref BucketListenerLambda]]
      RetentionInDays: 90
  PostScanActionTagLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join [
            "",
            [
              !Ref LambdaFunctionPrefix,
              "Tag-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Code:
        S3Bucket: !Sub ${FSSBucketName}-${AWS::Region}
        S3Key: !Sub ${FSSKeyPrefix}lambda/post-scan-action-tag.zip
      Handler: handler.lambda_handler
      Environment:
        Variables:
          stackARN: !Ref AWS::StackId
          HTTPS_PROXY:
            !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      MemorySize: 128
      Role: !GetAtt PostScanActionTagExecutionRole.Arn
      Runtime: python3.8
      Timeout: 15
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds:
          !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      DeadLetterConfig:
        TargetArn:
          !If [
            IsPostScanActionTagDLQEnabled,
            !Ref PostScanActionTagDLQARN,
            !Ref AWS::NoValue,
          ]
  PostScanActionTagLambdaAlias:
    Type: Custom::PostScanActionTagLambdaAlias
    Properties:
      ServiceToken: !GetAtt CreateLambdaAliasLambda.Arn
      FunctionName: !GetAtt PostScanActionTagLambda.Arn
      Name: TM-FSS-MANAGED
      Modified: 20211019.1
      # Template parameters
      FSSBucketName: !Ref FSSBucketName
      FSSKeyPrefix: !Ref FSSKeyPrefix
      NetworkProxy: !Ref NetworkProxy
      SecurityGroupIDs: !Ref SecurityGroupIDs
      SubnetIDs: !Ref SubnetIDs
  PostScanActionTagExecutionRole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "Tag-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      ManagedPolicyArns: !Split
        - ","
        - !Join
          - ","
          - - !If
              - HasAdditionalIAMPolicies
              - !Join [",", !Ref AdditionalIAMPolicies]
              - !Ref AWS::NoValue
            - !If
              - IsVPCEnabled
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetObjectTagging
                  - s3:PutObjectTagging
                Resource: !Sub arn:${AWS::Partition}:s3:::${S3BucketToScan}/*
  PostScanActionTagPolicyForDLQ: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsPostScanActionTagDLQEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join [
            "",
            [
              !Ref IAMPolicyPrefix,
              "sqs-permission-for-postscan-action-tag-dlq",
            ],
          ]
        - "sqs-permission-for-postscan-action-tag-dlq"
      Roles:
        - !Ref PostScanActionTagExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - sqs:SendMessage
            Resource: !Ref PostScanActionTagDLQARN
  PostScanActionTagKMSDecryptPolicyForDLQ: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsPostScanActionTagDLQSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join [
            "",
            [
              !Ref IAMPolicyPrefix,
              "kms-permission-for-postscan-action-tag-dlq",
            ],
          ]
        - "kms-permission-for-postscan-action-tag-dlq"
      Roles:
        - !Ref PostScanActionTagExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:Decrypt
              - kms:GenerateDataKey
            Resource: !Ref KMSKeyARNForDLQSSE
  PostScanActionTagInvokePermissionOfScanResultTopic: #ROLE_TO_MOVE_TO_VALIDATE
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt PostScanActionTagLambdaAlias.Arn
      Principal: sns.amazonaws.com
      SourceArn: !Ref ScanResultTopic
  PostScanActionTagLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [/, [/aws/lambda, !Ref PostScanActionTagLambda]]
      RetentionInDays: 90
  ManagementRoleS: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "Mgmt-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Join ["", [!Ref AWS::StackName, "-ManagementRole-", !Select [0,!Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]]]]]
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Ref TrendMicroManagementAccount
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                sts:ExternalId: !Ref ExternalID
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      ManagedPolicyArns: !If
        - HasAdditionalIAMPolicies
        - !Ref AdditionalIAMPolicies
        - !Ref AWS::NoValue
      Policies:
        - PolicyName: stack-management
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:CreateChangeSet
                  - cloudformation:ListStackResources
                  - cloudformation:DescribeStacks
                  - cloudformation:DescribeStackEvents
                  - cloudformation:DescribeStackResources
                  - cloudformation:DescribeStackResource
                  - cloudformation:DetectStackDrift
                  - cloudformation:DetectStackResourceDrift
                  - cloudformation:DescribeStackResourceDrifts
                  - cloudformation:GetStackPolicy
                  - cloudformation:GetTemplate
                Resource: !Ref AWS::StackId
        - PolicyName: lambda-management
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:UpdateFunctionCode
                  - lambda:UpdateFunctionConfiguration
                  - lambda:GetFunctionConfiguration
                  - lambda:PublishVersion
                  - lambda:ListVersionsByFunction
                  - lambda:CreateAlias
                  - lambda:UpdateAlias
                  - lambda:DeleteAlias
                  - lambda:ListAliases
                  - lambda:GetAlias
                  - lambda:GetFunction
                  - lambda:ListProvisionedConcurrencyConfigs
                  - lambda:GetProvisionedConcurrencyConfig
                  - lambda:GetFunctionConcurrency
                Resource:
                  - !GetAtt BucketListenerLambda.Arn
                  - !GetAtt PostScanActionTagLambda.Arn
                  - !Sub ${BucketListenerLambda.Arn}:*
                  - !Sub ${PostScanActionTagLambda.Arn}:*
        - PolicyName: lambda-logs-access
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:GetLogEvents
                  - logs:StartQuery
                  - logs:StopQuery
                  - logs:GetQueryResults
                  - logs:FilterLogEvents
                Resource:
                  - !GetAtt BucketListenerLogGroup.Arn
                  - !GetAtt PostScanActionTagLogGroup.Arn
  
  SetupBucketNotification:
    Type: Custom::SetupBucketNotificationLambda
    Condition: IsTriggeredWithObjectCreatedEvent
    DependsOn: BucketListenerInvokePermissionOfScanningBucket
    Properties:
      ServiceToken: !GetAtt SetupBucketNotificationLambda.Arn
      Bucket: !Ref S3BucketToScan
      LambdaArn: !GetAtt BucketListenerLambdaAlias.Arn
      Prefix: !Ref ObjectFilterPrefix
  SetupBucketNotificationLambda:
    Type: AWS::Lambda::Function
    Condition: IsTriggeredWithObjectCreatedEvent
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join [
            "",
            [
              !Ref LambdaFunctionPrefix,
              "Setup-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Environment:
        Variables:
          LambdaArn: !GetAtt BucketListenerLambda.Arn # deprecated, for handling the old custom resource input
          HTTPS_PROXY:
            !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      Handler: index.handler
      Role: !GetAtt SetupBucketNotificationExecutionRole.Arn
      Runtime: python3.8
      Timeout: 50
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds:
          !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      Code:
        ZipFile: |
          import os
          import traceback
          import json
          import urllib.request
          import boto3
          LAMBDA_CFG = 'LambdaFunctionConfigurations'
          LAMBDA_ARN = 'LambdaFunctionArn'
          SUCCESS = "SUCCESS"
          FAILED = "FAILED"
          s3 = boto3.client('s3')
          class BucketNotFound(Exception): pass
          def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False):
              responseUrl = event['ResponseURL']
              print(responseUrl)
              responseBody = {}
              responseBody['Status'] = responseStatus
              responseBody['Reason'] = 'See the details in CloudWatch Log Stream: ' + context.log_stream_name
              responseBody['PhysicalResourceId'] = physicalResourceId or context.log_stream_name
              responseBody['StackId'] = event['StackId']
              responseBody['RequestId'] = event['RequestId']
              responseBody['LogicalResourceId'] = event['LogicalResourceId']
              responseBody['NoEcho'] = noEcho
              responseBody['Data'] = responseData
              json_responseBody = json.dumps(responseBody)
              print("Response body:\n" + json_responseBody)
              headers = {
                  'content-type' : '',
                  'content-length' : str(len(json_responseBody))
              }
              request = urllib.request.Request(responseUrl, headers=headers, data=json_responseBody.encode('utf-8'), method='PUT')
              try:
                  with urllib.request.urlopen(request) as response:
                      print("Status code: " + response.reason)
              except Exception as e:
                  print("send(..) failed executing requests.put(..): " + str(e))
          def is_bucket_existing(bucket):
              try:
                  s3.head_bucket(Bucket=bucket)
                  return True
              except Exception as ex:
                  print('head_bucket exception: ' + str(ex))
                  if ex.response['Error']['Code'] == '404': return False
                  else: raise ex
          def find_and_remove_config(configs, arn, rules):
              configs[LAMBDA_CFG] = [
                  config for config in configs[LAMBDA_CFG] \
                  if config[LAMBDA_ARN] != arn \
                      or not compare_rules(rules, config.get('Filter', {}).get('Key', {}).get('FilterRules', [])) \
                      or 's3:ObjectCreated:*' not in config['Events']
              ]
          def delete_notification(bucket, arn, rules):
              if is_bucket_existing(bucket):
                  configs = get_configs(bucket)
                  if LAMBDA_CFG in configs:
                      find_and_remove_config(configs, arn, rules)
                      put_configs(bucket, configs)
          def get_configs(bucket):
              configs = s3.get_bucket_notification_configuration(Bucket=bucket)
              configs.pop('ResponseMetadata', None)
              print(f'get {bucket} config: {configs}')
              return configs
          def put_configs(bucket, configs):
              print(f'put {bucket} config: {configs}')
              s3.put_bucket_notification_configuration(Bucket=bucket, NotificationConfiguration=configs)
          def append_new_entry(configs, arn, rules):
              entry = {
                  LAMBDA_ARN: arn,
                  'Events': ['s3:ObjectCreated:*'],
                  'Filter': {
                      'Key': {
                          'FilterRules': rules,
                      }
                  }
              }
              if LAMBDA_CFG in configs: configs[LAMBDA_CFG].append(entry)
              else: configs[LAMBDA_CFG] = [entry]
          def compare_rules(a, b):
              a_prefix = ''
              a_suffix = ''
              b_prefix = ''
              b_suffix = ''
              for r in a:
                  if r['Name'].lower() == 'prefix': a_prefix = r['Value']
                  elif r['Name'].lower() == 'suffix': a_suffix = r['Value']
              for r in b:
                  if r['Name'].lower() == 'prefix': b_prefix = r['Value']
                  elif r['Name'].lower() == 'suffix': b_suffix = r['Value']
              return (a_prefix == b_prefix) and (a_suffix == b_suffix)
          def update_configs(configs, arn, rules, old_arn, old_rules):
              created = []
              for configKey in configs: created += [entry for entry in configs[configKey] if len([event for event in entry['Events'] if 's3:ObjectCreated' in event]) != 0]
              old_entries = [entry for entry in created if entry.get(LAMBDA_ARN, None) == old_arn]
              found_entry = False
              for entry in old_entries:
                  print(entry)
                  entry[LAMBDA_ARN] = arn
                  if compare_rules(old_rules, entry.get('Filter', {}).get('Key', {}).get('FilterRules', [])):
                      entry['Filter'] = { 'Key': { 'FilterRules': rules } }
                      found_entry = True
              if not found_entry:
                  append_new_entry(configs, arn, rules)
          def handler(event, context):
              print(event)
              status = SUCCESS
              bucket = event['ResourceProperties']['Bucket']
              arn = event['ResourceProperties'].get('LambdaArn', os.environ['LambdaArn'])
              prefix = event['ResourceProperties'].get('Prefix', None)
              try:
                  old_arn = event.get('OldResourceProperties', {}).get('LambdaArn', os.environ['LambdaArn']) if event['RequestType'] =='Update' else ''
                  old_prefix = event.get('OldResourceProperties', {}).get('Prefix', '') if event['RequestType'] =='Update' else ''
                  rules = [{'Name': 'prefix', 'Value': prefix if prefix else ''}]
                  old_rules = [{'Name': 'prefix', 'Value': old_prefix}]
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      if not is_bucket_existing(bucket): raise BucketNotFound('Bucket not found')
                      configs = get_configs(bucket)
                      update_configs(configs, arn, rules, old_arn, old_rules)
                      put_configs(bucket, configs)
                  elif event['RequestType'] == 'Delete':
                      if prefix is not None: # handling the old custom resource version without setting physical resource ID
                          delete_notification(bucket, arn, rules)
                      else:
                          print('Skip deleting notification for migrating from old resource without Prefix property')
              except Exception as ex:
                  print('Unhandled exception: ' + str(ex))
                  traceback.print_exc()
                  status = FAILED
              send(event, context, status, {}, f'{bucket}+{arn}')
  SetupBucketNotificationExecutionRole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Condition: IsTriggeredWithObjectCreatedEvent
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "Setup-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      ManagedPolicyArns: !Split
        - ","
        - !Join
          - ","
          - - !If
              - HasAdditionalIAMPolicies
              - !Join [",", !Ref AdditionalIAMPolicies]
              - !Ref AWS::NoValue
            - !If
              - IsVPCEnabled
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetBucketNotification
                  - s3:PutBucketNotification
                  - s3:ListBucket
                Resource: !Sub arn:${AWS::Partition}:s3:::*

  ScanningBucketAccessPoint:
    Type: AWS::S3::AccessPoint
    Condition: IsScanOnGetObjectEnabled
    Properties:
      Bucket: !Ref S3BucketToScan
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        IgnorePublicAcls: true
        BlockPublicPolicy: true
        RestrictPublicBuckets: true
  ScanningBucketObjectLambdaAccessPoint:
    Type: AWS::S3ObjectLambda::AccessPoint
    Condition: IsScanOnGetObjectEnabled
    Properties:
      Name: !Join
        - "-"
        - - "fss-olap"
          - !GetAtt ScanningBucketAccessPoint.Name
      ObjectLambdaConfiguration:
        SupportingAccessPoint: !Join
          - ""
          - - !Sub arn:${AWS::Partition}:s3:${AWS::Region}:${AWS::AccountId}:accesspoint/
            - !Ref ScanningBucketAccessPoint
        TransformationConfigurations:
          - Actions:
              - GetObject
            ContentTransformation:
              AwsLambda:
                FunctionArn: !GetAtt ScannerLambdaAlias.Arn
                FunctionPayload: !Join
                  - ""
                  - - '{"bucket":"'
                    - !Ref S3BucketToScan
                    - '", "reportObjectKey":'
                    - !If [IsReportObjectKey, "true", "false"]
                    - "}"
        CloudWatchMetricsEnabled: true
  GetLambdaLastConfig:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join [
            "",
            [
              !Ref LambdaFunctionPrefix,
              "Conf-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Description: Get Lambda config before creating/updating alias on Lambda function
      Handler: index.handler
      Runtime: python3.8
      Role: !GetAtt GetLambdaLastConfigExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          HTTPS_PROXY:
            !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds:
          !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      Code:
        ZipFile: |
          import boto3
          import traceback
          import json
          import urllib.request
          SUCCESS = "SUCCESS"
          FAILED = "FAILED"
          cfn = boto3.client('cloudformation')
          lambda_client = boto3.client('lambda')
          def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False):
              responseUrl = event['ResponseURL']
              print(responseUrl)
              responseBody = {}
              responseBody['Status'] = responseStatus
              responseBody['Reason'] = 'See the details in CloudWatch Log Stream: ' + context.log_stream_name
              responseBody['PhysicalResourceId'] = physicalResourceId or context.log_stream_name
              responseBody['StackId'] = event['StackId']
              responseBody['RequestId'] = event['RequestId']
              responseBody['LogicalResourceId'] = event['LogicalResourceId']
              responseBody['NoEcho'] = noEcho
              responseBody['Data'] = responseData
              json_responseBody = json.dumps(responseBody)
              # Do not print response body cause it might contains license (JWT)
              headers = {
                  'content-type' : '',
                  'content-length' : str(len(json_responseBody))
              }
              request = urllib.request.Request(responseUrl, headers=headers, data=json_responseBody.encode('utf-8'), method='PUT')
              try:
                  with urllib.request.urlopen(request) as response:
                      print("Status code: " + response.reason)
              except Exception as e:
                  print("send(..) failed executing requests.put(..): " + str(e))
          def handler(event, context):
              print(event)
              status = SUCCESS
              response_data = { 'Environment': {}, 'Layers': [] }
              try:
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      stack_id = event['StackId']
                      lambda_arn_output_key = event['ResourceProperties']['LambdaARNOutputKey']
                      lambda_alias_arn_output_key = event['ResourceProperties']['LambdaAliasARNOutputKey']

                      function_arn = None
                      cfn_response = cfn.describe_stacks(StackName=stack_id)
                      stack_outputs = cfn_response['Stacks'][0].get('Outputs', [])
                      for output in stack_outputs:
                          if output['OutputKey'] == lambda_alias_arn_output_key:
                              function_arn = output['OutputValue']
                              break
                          elif output['OutputKey'] == lambda_arn_output_key:
                              function_arn = output['OutputValue']

                      if function_arn:
                          function_config = lambda_client.get_function_configuration(FunctionName=function_arn)
                          response_data['Environment'] = function_config['Environment']['Variables']
                          response_data['Layers'] = function_config['Layers']
              except Exception as ex:
                  print('Unhandled exception: ' + str(ex))
                  traceback.print_exc()
                  status = FAILED
              finally:
                  send(event, context, status, response_data)
  GetLambdaLastConfigExecutionRole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "Conf-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      ManagedPolicyArns: !Split
        - ","
        - !Join
          - ","
          - - !If
              - HasAdditionalIAMPolicies
              - !Join [",", !Ref AdditionalIAMPolicies]
              - !Ref AWS::NoValue
            - !If
              - IsVPCEnabled
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: get-lambda-last-config
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStacks
                Resource: !Ref AWS::StackId
              - Effect: Allow
                Action:
                  - lambda:GetFunctionConfiguration
                Resource:
                  - !If
                    - HasLambdaFunctionPrefix
                    - !Join
                      - ""
                      - - !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:"
                        - !Ref LambdaFunctionPrefix
                        - "Scan-"
                        - !Select [
                            0,
                            !Split [
                              "-",
                              !Select [2, !Split ["/", !Ref AWS::StackId]],
                            ],
                          ]
                        - "*"
                    - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*ScannerLambda*
                  - !If
                    - HasLambdaFunctionPrefix
                    - !Join
                      - ""
                      - - !Sub "arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:"
                        - !Ref LambdaFunctionPrefix
                        - "SDL-"
                        - !Select [
                            0,
                            !Split [
                              "-",
                              !Select [2, !Split ["/", !Ref AWS::StackId]],
                            ],
                          ]
                    - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*ScannerDeadLetterLambda*
  CreateLambdaAliasLambdaScanner:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join [
            "",
            [
              !Ref LambdaFunctionPrefix,
              "alias-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Description: Create Lambda alias on Lambda function
      Handler: index.handler
      Runtime: python3.8
      Role: !GetAtt CreateLambdaAliasExecutionRole.Arn
      Timeout: 120
      Environment:
        Variables:
          HTTPS_PROXY:
            !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds:
          !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      Code:
        ZipFile: |
          import boto3
          import traceback
          import json
          import urllib.request
          import time
          from collections import defaultdict
          SUCCESS = "SUCCESS"
          FAILED = "FAILED"
          DEFAULT_ENV_VARIABLE_DICT = defaultdict(str, SCAN_CONFIG='{}')
          lambda_client = boto3.client('lambda')
          def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False):
              responseUrl = event['ResponseURL']
              print(responseUrl)
              responseBody = {}
              responseBody['Status'] = responseStatus
              responseBody['Reason'] = 'See the details in CloudWatch Log Stream: ' + context.log_stream_name
              responseBody['PhysicalResourceId'] = physicalResourceId or context.log_stream_name
              responseBody['StackId'] = event['StackId']
              responseBody['RequestId'] = event['RequestId']
              responseBody['LogicalResourceId'] = event['LogicalResourceId']
              responseBody['NoEcho'] = noEcho
              responseBody['Data'] = responseData
              json_responseBody = json.dumps(responseBody)
              print("Response body:\n" + json_responseBody)
              headers = {
                  'content-type' : '',
                  'content-length' : str(len(json_responseBody))
              }
              request = urllib.request.Request(responseUrl, headers=headers, data=json_responseBody.encode('utf-8'), method='PUT')
              try:
                  with urllib.request.urlopen(request) as response:
                      print("Status code: " + response.reason)
              except Exception as e:
                  print("send(..) failed executing requests.put(..): " + str(e))
          def publish_version_with_retry(function, retry_attempts=6):
              try:
                  return lambda_client.publish_version(FunctionName=function)
              except lambda_client.exceptions.ResourceConflictException as e:
                  if retry_attempts > 0:
                      print('publish_version failed with ResourceConflictException, retrying in 10 seconds...')
                      time.sleep(10)
                      return publish_version_with_retry(function, retry_attempts-1)
                  else: raise e
          def create_alias(function, name):
              version_result = publish_version_with_retry(function)
              return lambda_client.create_alias(FunctionName=function, Name=name, FunctionVersion=version_result['Version'])
          def update_alias(function, name):
              version_result = publish_version_with_retry(function)
              return lambda_client.update_alias(FunctionName=function, Name=name, FunctionVersion=version_result['Version'], RoutingConfig={})
          def delete_alias(function, name):
              lambda_client.delete_alias(FunctionName=function, Name=name)
          def get_function_configuration(function, qualifier=None):
              if (qualifier is not None):
                  return lambda_client.get_function_configuration(FunctionName=function, Qualifier=qualifier)
              else:
                  return lambda_client.get_function_configuration(FunctionName=function)
          def update_function_configuration(function, environments, layers):
              lambda_client.update_function_configuration(FunctionName=function, Environment=environments, Layers=layers)
          def replace_environments(env_vars_to_recover, last_env_vars, current_environments):
              for env_var in env_vars_to_recover:
                  current_environments['Variables'][env_var] = last_env_vars.get(env_var, DEFAULT_ENV_VARIABLE_DICT[env_var])
              return current_environments
          def find_recover_layer_arn(layers, keyword):
              found_arns = [layer_arn for layer_arn in layers if keyword in layer_arn]
              return found_arns[0] if len(found_arns) > 0 else ''
          def is_not_match_layer(layer_arn, keywords):
              return len(list(filter(lambda keyword: keyword in layer_arn, keywords))) == 0
          def replace_layers(layers_to_recover, last_layers, current_layers):
              get_arn = lambda layer: layer['Arn']
              old_layer_arns = list(map(get_arn, last_layers))
              current_layer_arns = list(map(get_arn, current_layers))
              for recover_layer, replacing_layers in layers_to_recover.items():
                  recover_layer_arn = find_recover_layer_arn(old_layer_arns, recover_layer)
                  if len(recover_layer_arn) == 0: break
                  current_layer_arns = [layer_arn for layer_arn in current_layer_arns if is_not_match_layer(layer_arn, replacing_layers)]
                  current_layer_arns.append(recover_layer_arn)
              return current_layer_arns
          def recover_lambda_function_config(current_function_name, last_env_vars, last_layers, env_vars_to_recover, layers_to_recover):
              current_version_info = get_function_configuration(current_function_name)
              new_environments = replace_environments(env_vars_to_recover, last_env_vars, current_version_info['Environment'])
              new_layers = replace_layers(layers_to_recover, last_layers, current_version_info.get('Layers', []))
              update_function_configuration(current_function_name, new_environments, new_layers)
          def handler(event, context):
              # Do not print LastEnvVars values cause it might contain license (JWT)
              last_env_vars = event['ResourceProperties'].pop('LastEnvVars', {})
              event.get('OldResourceProperties', {}).pop('LastEnvVars', None)
              print(event)
              print('ResourceProperties.LastEnvVars:', last_env_vars.keys())
              status = SUCCESS
              response_data = {}
              try:
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      function_name = event['ResourceProperties']['FunctionName']
                      alias_name = event['ResourceProperties']['Name']
                      last_layers = event['ResourceProperties'].get('LastLayers', [])
                      env_vars_to_recover = event['ResourceProperties'].get('EnvVarsToRecover', [])
                      layers_to_recover = event['ResourceProperties'].get('LayersToRecover', {})
                      recover_lambda_function_config(function_name, last_env_vars, last_layers, env_vars_to_recover, layers_to_recover)
                      if event['RequestType'] == 'Create':
                          alias_result = create_alias(function_name, alias_name)
                      else:
                          old_function_name = event['OldResourceProperties']['FunctionName']
                          old_alias_name = event['OldResourceProperties']['Name']
                          if function_name == old_function_name and alias_name == old_alias_name:
                              alias_result = update_alias(function_name, alias_name)
                          else:
                              alias_result = create_alias(function_name, alias_name)
                              delete_alias(old_function_name, old_alias_name)
                      response_data = {'Arn': alias_result['AliasArn']}
              except Exception as ex:
                  print('Unhandled exception: ' + str(ex))
                  traceback.print_exc()
                  status = FAILED
              finally:
                  send(event, context, status, response_data, response_data.get('Arn', None))
  CreateLambdaAliasExecutionRole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "Ver-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      ManagedPolicyArns: !Split
        - ","
        - !Join
          - ","
          - - !If
              - HasAdditionalIAMPolicies
              - !Join [",", !Ref AdditionalIAMPolicies]
              - !Ref AWS::NoValue
            - !If
              - IsVPCEnabled
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: create-lambda-function-version-alias
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:PublishVersion
                  - lambda:CreateAlias
                  - lambda:UpdateAlias
                  - lambda:DeleteAlias
                  - lambda:GetFunctionConfiguration
                  - lambda:UpdateFunctionConfiguration
                Resource:
                  - !GetAtt ScannerLambda.Arn
                  - !GetAtt ScannerDeadLetterLambda.Arn
                  - !GetAtt BucketListenerLambda.Arn
                  - !GetAtt PostScanActionTagLambda.Arn
              - Effect: Allow
                Action:
                  - lambda:GetLayerVersion
                Resource:
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${TrendMicroManagementAccount}:layer:Scanner*LambdaLayer*:*
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:layer:Scanner*LambdaLayer:*
                  - !If
                    - HasLambdaLayerPrefix
                    - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:layer:${LambdaLayerPrefix}Scanner*:*
                    - !Ref AWS::NoValue
  ScannerQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - HasSQSQueuePrefix
        - !Join [
            "",
            [
              !Ref SQSQueuePrefix,
              "ScannerQueue-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      DelaySeconds: 0
      MaximumMessageSize: 262144
      MessageRetentionPeriod: 3600
      ReceiveMessageWaitTimeSeconds: 0
      VisibilityTimeout: 720
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ScannerDLQ.Arn
        maxReceiveCount: 2
      KmsDataKeyReusePeriodSeconds: !If
        - IsQueueSSEKMSEnabled
        - 86400
        - !Ref AWS::NoValue
      KmsMasterKeyId: !If
        - IsQueueSSEKMSEnabled
        - !Ref KMSKeyARNForQueueSSE
        - !Ref AWS::NoValue
  ScannerQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: send_message_from_accounts
            Effect: Allow
            Principal: !Ref AWS::NoValue
            Action:
              - sqs:SendMessage
            Resource: !GetAtt ScannerQueue.Arn
      Queues:
        - !Ref ScannerQueue
  ScannerDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - HasSQSQueuePrefix
        - !Join [
            "",
            [
              !Ref SQSQueuePrefix,
              "ScannerDLQ-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      DelaySeconds: 0
      MaximumMessageSize: 262144
      MessageRetentionPeriod: 3600
      ReceiveMessageWaitTimeSeconds: 0
      VisibilityTimeout: 720
      KmsDataKeyReusePeriodSeconds: !If
        - IsQueueSSEKMSEnabled
        - 86400
        - !Ref AWS::NoValue
      KmsMasterKeyId: !If
        - IsQueueSSEKMSEnabled
        - !Ref KMSKeyARNForQueueSSE
        - !Ref AWS::NoValue
  ScannerLambda:
    Type: AWS::Lambda::Function
    DependsOn: ScannerLambdaLastConfig
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join [
            "",
            [
              !Ref LambdaFunctionPrefix,
              "Scan-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Code:
        S3Bucket: !Sub ${FSSBucketName}-${AWS::Region}
        S3Key: !Sub ${FSSKeyPrefix}lambda/scanner-lambda-python.zip
      Handler: lambdas.handler.lambda_handler
      Environment:
        Variables:
          queueURL: !Ref ScannerQueue
          stackARN: !Ref AWS::StackId
          HTTPS_PROXY:
            !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
          SCAN_CONFIG: "{}"
      MemorySize: 512
      Role: !GetAtt ScannerExecutionRole.Arn
      Runtime: python3.8
      Timeout: 120
      Layers:
        - !Ref ScannerPatternLambdaLayer
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds:
          !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      EphemeralStorage:
        Size: !Ref ScannerEphemeralStorage
  ScannerLambdaLastConfig:
    Type: Custom::ScannerLambdaLastConfig
    Properties:
      ServiceToken: !GetAtt GetLambdaLastConfig.Arn
      LambdaARNOutputKey: ScannerLambdaARN
      LambdaAliasARNOutputKey: ScannerLambdaAliasARN
      Modified: 20220906.1
      # Template parameters
      CloudOneRegion: !Ref CloudOneRegion
      FSSBucketName: !Ref FSSBucketName
      FSSKeyPrefix: !Ref FSSKeyPrefix
      LambdaLayerPrefix: !Ref LambdaLayerPrefix
      NetworkProxy: !Ref NetworkProxy
      ScannerEphemeralStorage: !Ref ScannerEphemeralStorage
      SecurityGroupIDs: !Ref SecurityGroupIDs
      SubnetIDs: !Ref SubnetIDs
      TrendMicroManagementAccount: !Ref TrendMicroManagementAccount
  ScannerLambdaAlias:
    Type: Custom::ScannerLambdaAlias
    Properties:
      ServiceToken: !GetAtt CreateLambdaAliasLambdaScanner.Arn
      FunctionName: !GetAtt ScannerLambda.Arn
      Name: TM-FSS-MANAGED
      Modified: 20220906.1
      # Template parameters
      CloudOneRegion: !Ref CloudOneRegion
      FSSBucketName: !Ref FSSBucketName
      FSSKeyPrefix: !Ref FSSKeyPrefix
      LambdaLayerPrefix: !Ref LambdaLayerPrefix
      NetworkProxy: !Ref NetworkProxy
      ScannerEphemeralStorage: !Ref ScannerEphemeralStorage
      SecurityGroupIDs: !Ref SecurityGroupIDs
      SubnetIDs: !Ref SubnetIDs
      TrendMicroManagementAccount: !Ref TrendMicroManagementAccount
      # Other inputs
      LastEnvVars: !GetAtt ScannerLambdaLastConfig.Environment
      LastLayers: !GetAtt ScannerLambdaLastConfig.Layers
      EnvVarsToRecover:
        - LICENSE
        - FSS_API_ENDPOINT
        - SCAN_CONFIG
      LayersToRecover:
        # Find the layer pushed by FSS backend and replace the layer created by templates.
        # The layer name could be:
        # 1. ScannerPatternLambdaLayer_xxxxxx (pushed by FSS backend)
        # 2. ScannerPatternLambdaLayer (created by templates without prefix parameters)
        # 3. <prefix>-ScannerPattern (created by templates with prefix parameters)
        ScannerPatternLambdaLayer_:
          - ScannerPattern
  ScannerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [/, [/aws/lambda, !Ref ScannerLambda]]
      RetentionInDays: 90
  ScannerPatternLambdaLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !If
        - HasLambdaLayerPrefix
        - !Join ["", [!Ref LambdaLayerPrefix, "ScannerPattern"]]
        - !Ref AWS::NoValue
      Content:
        S3Bucket: !Sub ${FSSBucketName}-${AWS::Region}
        S3Key: !Sub ${FSSKeyPrefix}patterns/pattern-icrc-269.zip
      Description: Anti-Malware pattern layer for scanner lambda function.
  ScannerEventSourceFromScannerQueue:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 1
      Enabled: true
      EventSourceArn: !GetAtt ScannerQueue.Arn
      FunctionName: !GetAtt ScannerLambdaAlias.Arn
  ScannerDeadLetterLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join [
            "",
            [
              !Ref LambdaFunctionPrefix,
              "SDL-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Code:
        S3Bucket: !Sub ${FSSBucketName}-${AWS::Region}
        S3Key: !Sub ${FSSKeyPrefix}lambda/scanner-dlq-lambda-python.zip
      Handler: lambdas.scanner_dlq_handler.lambda_handler
      Environment:
        Variables:
          stackARN: !Ref AWS::StackId
          HTTPS_PROXY:
            !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      MemorySize: 128
      Role: !GetAtt ScannerDeadLetterExecutionRole.Arn
      Runtime: python3.8
      Timeout: 60
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds:
          !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
  ScannerDeadLetterLambdaAlias:
    Type: Custom::ScannerDeadLetterLambdaAlias
    Properties:
      ServiceToken: !GetAtt CreateLambdaAliasLambdaScanner.Arn
      FunctionName: !GetAtt ScannerDeadLetterLambda.Arn
      Name: TM-FSS-MANAGED
      Modified: 20210708.1
      # Template parameters
      FSSBucketName: !Ref FSSBucketName
      FSSKeyPrefix: !Ref FSSKeyPrefix
      NetworkProxy: !Ref NetworkProxy
      SecurityGroupIDs: !Ref SecurityGroupIDs
      SubnetIDs: !Ref SubnetIDs
  ScannerDeadLetterLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [/, [/aws/lambda, !Ref ScannerDeadLetterLambda]]
      RetentionInDays: 90
  ScannerDeadLetterEventSourceFromDLQ:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 1
      Enabled: true
      EventSourceArn: !GetAtt ScannerDLQ.Arn
      FunctionName: !GetAtt ScannerDeadLetterLambdaAlias.Arn
  ScannerExecutionRole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "Scan-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      ManagedPolicyArns: !Split
        - ","
        - !Join
          - ","
          - - !If
              - HasAdditionalIAMPolicies
              - !Join [",", !Ref AdditionalIAMPolicies]
              - !Ref AWS::NoValue
            - !If
              - IsVPCEnabled
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:ChangeMessageVisibility
                Resource: !GetAtt ScannerQueue.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Sub arn:${AWS::Partition}:sns:*:*:*-ScanResultTopic-*
              - Effect: Allow # https://docs.aws.amazon.com/AmazonS3/latest/userguide/olap-policies.html
                Action:
                  - s3-object-lambda:WriteGetObjectResponse
                Resource: "*"
  ScannerExecutionRoleKMSDecryptPolicyForSQS: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsQueueSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ["", [!Ref IAMPolicyPrefix, "kms-permission-for-sqs"]]
        - "kms-permission-for-sqs"
      Roles:
        - !Ref ScannerExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:Decrypt
            Resource: !Ref KMSKeyARNForQueueSSE
  ScannerExecutionRoleKMSDecryptPolicyForSNS: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsTopicSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ["", [!Ref IAMPolicyPrefix, "kms-permission-for-sns"]]
        - "kms-permission-for-sns"
      Roles:
        - !Ref ScannerExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:GenerateDataKey
              - kms:Decrypt
            Resource: !Ref KMSKeyARNForTopicSSE
  ScannerDeadLetterExecutionRole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "SDL-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      ManagedPolicyArns: !Split
        - ","
        - !Join
          - ","
          - - !If
              - HasAdditionalIAMPolicies
              - !Join [",", !Ref AdditionalIAMPolicies]
              - !Ref AWS::NoValue
            - !If
              - IsVPCEnabled
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
              - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                Resource: !GetAtt ScannerDLQ.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Sub arn:${AWS::Partition}:sns:*:*:*-ScanResultTopic-*
  ScannerDeadLetterExecutionRoleKMSDecryptPolicyForSQS: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Condition: IsQueueSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ["", [!Ref IAMPolicyPrefix, "kms-permission-for-sqs"]]
        - "kms-permission-for-sqs"
      Roles:
        - !Ref ScannerDeadLetterExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:Decrypt
            Resource: !Ref KMSKeyARNForQueueSSE
  ManagementRole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join [
            "",
            [
              !Ref IAMRolePrefix,
              "Mgmt-",
              !Select [
                0,
                !Split ["-", !Select [2, !Split ["/", !Ref AWS::StackId]]],
              ],
            ],
          ]
        - !Ref AWS::NoValue
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Ref TrendMicroManagementAccount
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                sts:ExternalId: !Ref ExternalID
      ManagedPolicyArns: !If
        - HasAdditionalIAMPolicies
        - !Ref AdditionalIAMPolicies
        - !Ref AWS::NoValue
      PermissionsBoundary:
        !If [
          HasPermissionsBoundary,
          !Ref PermissionsBoundary,
          !Ref AWS::NoValue,
        ]
      Policies:
        - PolicyName: stack-management
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:CreateChangeSet
                  - cloudformation:ListStackResources
                  - cloudformation:DescribeStacks
                  - cloudformation:DescribeStackEvents
                  - cloudformation:DescribeStackResources
                  - cloudformation:DescribeStackResource
                  - cloudformation:DetectStackDrift
                  - cloudformation:DetectStackResourceDrift
                  - cloudformation:DescribeStackResourceDrifts
                  - cloudformation:GetStackPolicy
                  - cloudformation:GetTemplate
                Resource: !Ref AWS::StackId
        - PolicyName: queue-management
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sqs:SetQueueAttributes
                  - sqs:GetQueueAttributes
                  - sqs:ListDeadLetterSourceQueues
                Resource:
                  - !GetAtt ScannerQueue.Arn
                  - !GetAtt ScannerDLQ.Arn
        - PolicyName: lambda-management
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:UpdateFunctionCode
                  - lambda:UpdateFunctionConfiguration
                  - lambda:GetFunctionConfiguration
                  - lambda:PublishVersion
                  - lambda:ListVersionsByFunction
                  - lambda:CreateAlias
                  - lambda:UpdateAlias
                  - lambda:DeleteAlias
                  - lambda:ListAliases
                  - lambda:GetAlias
                  - lambda:GetFunction
                  - lambda:ListProvisionedConcurrencyConfigs
                  - lambda:GetProvisionedConcurrencyConfig
                  - lambda:GetFunctionConcurrency
                Resource:
                  - !GetAtt ScannerLambda.Arn
                  - !GetAtt ScannerDeadLetterLambda.Arn
                  - !Sub ${ScannerLambda.Arn}:*
                  - !Sub ${ScannerDeadLetterLambda.Arn}:*
              - Effect: Allow
                Action:
                  - lambda:GetEventSourceMapping
                Resource:
                  - !Sub
                    - arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:event-source-mapping:${MappingID}
                    - MappingID: !Ref ScannerEventSourceFromScannerQueue
                  - !Sub
                    - arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:event-source-mapping:${MappingID}
                    - MappingID: !Ref ScannerDeadLetterEventSourceFromDLQ
              - Effect: Allow
                Action:
                  - lambda:GetLayerVersion
                Resource:
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${TrendMicroManagementAccount}:layer:Scanner*LambdaLayer*:*
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:layer:Scanner*LambdaLayer:*
                  - !If
                    - HasLambdaLayerPrefix
                    - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:layer:${LambdaLayerPrefix}Scanner*:*
                    - !Ref AWS::NoValue
        - PolicyName: lambda-logs-access
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:GetLogEvents
                  - logs:StartQuery
                  - logs:StopQuery
                  - logs:GetQueryResults
                  - logs:FilterLogEvents
                Resource:
                  - !GetAtt ScannerLogGroup.Arn
                  - !GetAtt ScannerDeadLetterLogGroup.Arn
  ManagementRoleGetRolePolicy: #ROLE_TO_MOVE
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ["", [!Ref IAMPolicyPrefix, "role-management"]]
        - "role-management"
      Roles:
        - !Ref ManagementRole
        - !Ref ManagementRoleS
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - iam:GetRolePolicy
            Resource: 
              - !GetAtt ManagementRole.Arn
              - !GetAtt ManagementRoleS.Arn


#PROMOTE/QUARANTINE
  storagelambdarole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      RoleName: !Join ["-",[!Ref AWS::StackName, !Ref AWS::Region,"storage"]]
  storagelambdarolepolicy: #ROLE_TO_MOVE
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: !Ref storagelambdarole
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - s3:GetObject
              - s3:DeleteObject
              - s3:GetObjectTagging
            Resource:
              - !Sub arn:${AWS::Partition}:s3:::${S3BucketToScan}/*
          - Effect: Allow
            Action:
              - s3:ListBucket
            Resource:
              - !Sub arn:${AWS::Partition}:s3:::${S3BucketToScan}
          - Effect: Allow
            Action:
              - s3:PutObject
              - s3:PutObjectTagging
              - !If
                - PutACL
                - s3:PutObjectAcl
                - !Ref AWS::NoValue
            Resource:
              - !If
                - PromoteEnabled
                - !Sub arn:${AWS::Partition}:s3:::${PromoteBucketName}/*
                - !Ref AWS::NoValue
              - !If
                - QuarantineEnabled
                - !Sub arn:${AWS::Partition}:s3:::${QuarantineBucketName}/*
                - !Ref AWS::NoValue
      Roles:
        - !Ref storagelambdarole

  PromoteOrQuarantineLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.8
      MemorySize: 512
      Timeout: 30
      TracingConfig:
        Mode: Active
      Environment:
        Variables:
          PROMOTEBUCKET: !Ref PromoteBucketName
          PROMOTEMODE: !Ref PromoteMode
          QUARANTINEBUCKET: !Ref QuarantineBucketName
          QUARANTINEMODE: !Ref QuarantineMode
          ACL: !Ref ACL
      Role: !GetAtt
        - storagelambdarole
        - Arn
      Code:
        ZipFile: |
          import os
          import re
          import json
          import time
          import urllib.parse

          import boto3
          from boto3.s3.transfer import TransferConfig
          from botocore.client import Config
          from botocore.exceptions import ClientError

          VALID_ACL = {
              'private',
              'public-read',
              'public-read-write',
              'authenticated-read',
              'aws-exec-read',
              'bucket-owner-read',
              'bucket-owner-full-control',
          }

          VALID_METADATA = [
              'CacheControl',
              'ContentDisposition',
              'ContentEncoding',
              'ContentLanguage',
              'ContentType',
              'Metadata',
              'WebsiteRedirectLocation',
              'Expires'
          ]

          MODES = {
              'move',
              'copy',
          }

          DEFAULT_MODE = 'move'
          S3_DOMAIN_PATTERN = 's3(\..+)?\.amazonaws.com'
          FSS_TAG_PREFIX = 'fss-'

          CODE_EMPTY = 0
          CODE_SKIP_MULTIPLE = 100
          CODE_MISC = 199

          CODE_MESSAGES = {
              CODE_EMPTY: '',
              CODE_SKIP_MULTIPLE : 'incomplete scan due to multiple reasons',
              101: 'incomplete archive file extraction due to file too large',
              102: 'incomplete archive file extraction due to too many files in archive',
              103: 'incomplete archive file extraction due to too many archive layers',
              104: 'incomplete archive file extraction due to compression ratio exceeds limit',
              105: 'incomplete archive file extraction due to unsupported compression method',
              106: 'incomplete archive file extraction due to corrupted compression file',
              107: 'incomplete archive file extraction due to archive file encryption',
              108: 'incomplete scan due to Microsoft Office file encryption',
              CODE_MISC: 'incomplete scan due to miscellaneous reason. Provide the fss-scan-detail-code tag value to Trend Micro support',
          }

          S3_MAX_CONCURRENCY = 940
          S3_MULTIPART_CHUNK_SIZE = 16 * 1024 * 1024   # 16MB
          S3_MAX_POOL_CONNECTIONS = 940
          S3_MAX_ATTEMPTS = 100

          transfer_config = TransferConfig(max_concurrency=S3_MAX_CONCURRENCY, multipart_chunksize=S3_MULTIPART_CHUNK_SIZE)
          config = Config(max_pool_connections=S3_MAX_POOL_CONNECTIONS, retries = {'max_attempts': S3_MAX_ATTEMPTS})
          s3 = boto3.client('s3', config=config)

          def get_mode_from_env(mode_key):
              mode = os.environ.get(mode_key, 'move').lower()
              return mode if mode in MODES else DEFAULT_MODE

          def get_promote_mode():
              return get_mode_from_env('PROMOTEMODE')

          def get_quarantine_mode():
              return get_mode_from_env('QUARANTINEMODE')

          def parse_s3_object_url(url_string):
              url = urllib.parse.urlparse(url_string)
              # check pre-signed URL type, path or virtual
              if re.fullmatch(S3_DOMAIN_PATTERN, url.netloc):
                  bucket = url.path.split('/')[1]
                  s3_object = '/'.join(url.path.split('/')[2:])
              else:
                  bucket = url.netloc.split('.')[0]
                  s3_object = url.path[1:]
              object_key = urllib.parse.unquote_plus(s3_object)

              return bucket, object_key

          def get_existing_tag_set(bucket_name, object_key):
              try:
                  response = s3.get_object_tagging(Bucket=bucket_name, Key=object_key)
                  return list(
                      f'{urllib.parse.quote_plus(tag["Key"])}={urllib.parse.quote_plus(tag["Value"])}'
                      for tag in response['TagSet']
                      if not tag['Key'].startswith(FSS_TAG_PREFIX)
                  )
              except ClientError as ex:
                  print('failed to get existing tags: ' + str(ex))
                  return None

          def get_metadata(bucket_name, object_key):
              try:
                  metadata = s3.head_object(Bucket=bucket_name, Key=object_key)
                  return dict(filter(lambda elem: elem[0] in VALID_METADATA, metadata.items()))
              except ClientError as ex:
                  print('failed to get existing metadata: ' + str(ex))
                  return None

          def copy_object(source_bucket, source_key, dest_bucket, dest_key, tags, metadata, acl=None):
              params = {
                  'TaggingDirective': 'REPLACE',
                  'Tagging': '&'.join(tags),
                  **(metadata if metadata else {})
              }

              copy_source = {
                  'Bucket': source_bucket,
                  'Key': source_key
              }

              if acl and acl in VALID_ACL:
                  params['ACL'] = acl

              s3.copy(copy_source, dest_bucket, dest_key, params, Config=transfer_config)

          def delete_objects(bucket, prefix, objects):
              objects = {'Objects': [{'Key': prefix + o} for o in objects]}
              s3.delete_objects(Bucket=bucket, Delete=objects)

          def lambda_handler(event, context):
              acl = os.environ.get('ACL')

              quarantine_bucket = os.environ.get('QUARANTINEBUCKET')
              promote_bucket = os.environ.get('PROMOTEBUCKET')

              promote_mode = get_promote_mode()
              quarantine_mode = get_quarantine_mode()

              for record in event['Records']:
                  message = json.loads(record['Sns']['Message'])
                  print(json.dumps(message))

                  if message['scanner_status'] != 0:
                      print('Skip: ', message['scanner_status_message'])
                      continue

                  src_bucket, object_key = parse_s3_object_url(message['file_url'])
                  print('Source Bucket: ', src_bucket)
                  print('Object Key: ', object_key)

                  scanning_result = message['scanning_result']
                  findings = scanning_result.get('Findings')

                  operation = 'quarantine' if findings else 'promotion'
                  mode = quarantine_mode if findings else promote_mode
                  dst_bucket = quarantine_bucket if findings else promote_bucket
                  scan_result = 'malicious' if findings else 'no issues found'
                  scan_date = time.strftime("%Y/%m/%d %H:%M:%S", time.localtime(message['timestamp']))

                  if not dst_bucket:
                      print(f'Skip: No bucket specified for {operation}')
                      continue

                  codes = scanning_result['Codes']
                  code = CODE_EMPTY
                  if len(codes) > 0:
                      code = CODE_SKIP_MULTIPLE if len(codes) > 1 else codes[0]
                  tags = [
                      f'{FSS_TAG_PREFIX}scanned=true',
                      f'{FSS_TAG_PREFIX}scan-date={urllib.parse.quote_plus(scan_date)}',
                      f'{FSS_TAG_PREFIX}scan-result={urllib.parse.quote_plus(scan_result)}',
                      f'{FSS_TAG_PREFIX}scan-detail-code={str(code)}',
                      f'{FSS_TAG_PREFIX}scan-detail-message={urllib.parse.quote_plus(CODE_MESSAGES.get(code, CODE_MESSAGES[CODE_MISC]))}',
                  ]
                  existing_tag_set = get_existing_tag_set(src_bucket, object_key)
                  if existing_tag_set:
                      tags.extend(existing_tag_set)

                  metadata = get_metadata(src_bucket, object_key)

                  copy_object(
                      source_bucket=src_bucket,
                      dest_bucket=dst_bucket,
                      source_key=object_key,
                      dest_key=object_key,
                      tags=tags,
                      metadata=metadata,
                      acl=acl,
                  )

                  if mode == 'move':
                      delete_objects(bucket=src_bucket, prefix='', objects=[object_key])

                  print(f'File {operation} successful (mode: {mode})')
  ScanResultTopicPostScanSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: lambda
      Endpoint: !GetAtt PromoteOrQuarantineLambda.Arn
      TopicArn: !Ref ScanResultTopic
  LambdaInvokePermission: 
    Type: AWS::Lambda::Permission
    Properties: 
      Action: lambda:InvokeFunction
      Principal: sns.amazonaws.com
      SourceArn: !Ref ScanResultTopic
      FunctionName: !Ref PromoteOrQuarantineLambda

#Script to add in the FSS Console
  addtofsslambda:
    DependsOn: 
      - ManagementRole
      - ManagementRoleS
      - addtofsslambdarole
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.8
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          import os
          import urllib3
          import json
          import time
          import boto3

          http = urllib3.PoolManager()
          fss_key = os.environ["FSS_API"]
          c1_region = os.environ["C1_REGION"]

          def lambda_handler(event, context):
              # get secret
              secrets = boto3.client('secretsmanager').get_secret_value(SecretId=fss_key)
              sm_data = json.loads(secrets["SecretString"])
              new_api_format = sm_data["c1apikey"]
              cloud_one_api_key = "ApiKey "+new_api_format

              url = "https://filestorage."+c1_region+".cloudone.trendmicro.com/api/stacks"
              
              headers = {
                'Api-Version': 'v1',
                'Content-Type': 'application/json',
                'Authorization': cloud_one_api_key
              }
              
              payloadScanner = json.dumps({
                "provider": "aws",
                "details": {
                  "managementRole": os.environ.get('MANAGEMENT_ROLE_SCANNER')
                },
                "type": "scanner"
              })
              
              responseScanner = http.request("POST", url, headers=headers, body=payloadScanner)

              respScanner = json.loads(responseScanner.data.decode('utf-8'))
            
              status = False
              
              while status == False:
                time.sleep(3)
                urlGetStack = f'https://filestorage.{c1_region}.cloudone.trendmicro.com/api/stacks/{respScanner["stackID"]}'
                responseStack = http.request("GET", urlGetStack, headers=headers)
                jsonResponse = json.loads(responseStack.data.decode('utf-8'))
                if "status" in jsonResponse:
                  if jsonResponse["status"] == "ok":
                    status = True
                  
              payloadStorage = json.dumps({
                "provider": "aws",
                "details": {
                  "managementRole": os.environ.get('MANAGEMENT_ROLE_STORAGE')
                },
                "type": "storage",
                "scannerStack": respScanner["stackID"]
              })
              
              responseStorage = http.request("POST", url, headers=headers, body=payloadStorage)

              respStorage = json.loads(responseStorage.data.decode('utf-8'))

              return {
                  'statusCode': 200,
                  'stack_scanner': json.dumps(respScanner),
                  'stack_storage': json.dumps(respStorage)
              }
      TracingConfig:
        Mode: Active
      MemorySize: 128
      Timeout: 120
      Role: !GetAtt
        - addtofsslambdarole
        - Arn
      Environment:
        Variables:
          C1_REGION: !Ref CloudOneRegion
          FSS_API: !Ref c1api
          MANAGEMENT_ROLE_SCANNER: !GetAtt ManagementRole.Arn
          MANAGEMENT_ROLE_STORAGE: !GetAtt ManagementRoleS.Arn

  addtofsslambdarole: #ROLE_TO_MOVE
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaRole
      RoleName: !Join ["-",[!Ref AWS::StackName, !Ref AWS::Region,"STORAGE_FSS"]]

  storagelambdasecretrolepolicy: #ROLE_TO_MOVE
    Type: "AWS::IAM::Policy"
    Properties:
      PolicyName: !Join ["-",[!Ref AWS::StackName, !Ref AWS::Region,"ROLE_GET_SECRET"]]
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - "secretsmanager:GetSecretValue"     
            Resource: !Ref c1api
      Roles:
        - !Ref addtofsslambdarole

  LambdaInvokerFunction:
    DependsOn: 
      - addtofsslambda
      - addtofsslambdarole
    Type: AWS::Lambda::Function
    Properties:
      Environment:
        Variables:
          function_name: !Ref addtofsslambda
      Code:
        ZipFile: |
          import os

          import boto3, json
          
          import cfnresponse

          function_name = os.environ["function_name"]

          def handler(event, context):
              print('EVENT:[{}]'.format(event))
              lambda_client = boto3.client('lambda')
              test_event = '{"name":"test1"}'
              lambda_client.invoke(
                  FunctionName=function_name,
                  InvocationType='Event',
                  Payload=test_event,
              )
              responseValue = 120
              responseData = {}
              responseData['Data'] = responseValue
              cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
      Handler: index.handler
      Role: !GetAtt
        - addtofsslambdarole
        - Arn
      Runtime: python3.7
      Timeout: 120

  Primerinvoke:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: LambdaInvokerFunction
    Version: "1.0"
    Properties:
      ServiceToken: !GetAtt LambdaInvokerFunction.Arn


Outputs:
  BucketListenerRoleARN:
    Value: !GetAtt BucketListenerExecutionRole.Arn
    Description: The ARNs of the lambda execution role for SQS in scanner stack to accept scan requests from.
  CloudOneRegion:
    Value: !Ref CloudOneRegion
    Description: The region of the Trend Micro Cloud One services.
  ScannerQueueURL:
    Value: !Ref ScannerQueue
    Description: The SQS URL for storage stacks to publish events to.
  ScannerExecutionRoleARN:
    Value: !GetAtt ScannerExecutionRole.Arn
    Description: The ARNs of the lambda execution role for Lambda in the scanner stack to execute scan requests.
  ScannerStackManagementRoleARN:
    Value: !GetAtt ManagementRole.Arn
    Description: The ARN of the IAM role for File Storage Security backend services to manage the deployed resources.
  ScanningBucket:
    Value: !Ref S3BucketToScan
    Description: The name of the scanning bucket in storage stack.
  ScanOnGetObjectAccessPointARN:
    Condition: IsScanOnGetObjectEnabled
    Value: !GetAtt ScanningBucketObjectLambdaAccessPoint.Arn
    Description: Using this ARN to get objects will have them scanned by File Storage Security before they are returned.
  ScanResultTopicARN:
    Value: !Ref ScanResultTopic
    Description: The ARN of the scan result SNS topic in storage stack.
  StorageStackManagementRoleARN:
    Value: !GetAtt ManagementRoleS.Arn
    Description: The ARN of the IAM role for File Storage Security backend services to manage the deployed resources.
  ScannerLambdaARN:
    Value: !GetAtt ScannerLambda.Arn
  ScannerLambdaAliasARN:
    Value: !GetAtt ScannerLambdaAlias.Arn
  PostScanActionTagLambdaAliasARN:
    Value: !GetAtt PostScanActionTagLambdaAlias.Arn
  BucketListenerLambdaAliasARN:
    Value: !GetAtt BucketListenerLambdaAlias.Arn
